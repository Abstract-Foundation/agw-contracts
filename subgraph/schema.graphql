type ClaveAccount @entity {
  "account address"
  id: Bytes!
  creationDate: BigInt
  deployDate: BigInt
  recoveryCount: Int!
  hasRecovery: Boolean!
  isRecovering: Boolean!
  "account implementation address"
  implementation: Bytes!
  # erc20balances: [ERC20Balance!]! @derivedFrom(field: "account")
  owners: [Owner!]! @derivedFrom(field: "account")
  transactions: [ClaveTransaction!]! @derivedFrom(field: "sender")
  inAppSwaps: [InAppSwap!]! @derivedFrom(field: "account")
}

# type ERC20 @entity(immutable: true) {
#   "token address"
#   id: Bytes!
#   name: String!
#   symbol: String!
#   decimals: Int!
# }

# type ERC20Balance @entity {
#   "account.id.concat(ERC20.id)"
#   id: Bytes!
#   account: ClaveAccount!
#   token: ERC20!
#   amount: BigDecimal!
# }

enum OwnerType {
  "k1"
  Address
  "r1"
  PublicKey
}

type Owner @entity(immutable: true) {
  "account.id.concat(owner)"
  id: Bytes!
  account: ClaveAccount!
  "k1 or r1"
  ownerType: OwnerType!
  "public key or address"
  owner: Bytes!
  "date added as owner to account"
  dateAdded: BigInt!
}

enum Paymaster {
  None
  ERC20
  Gasless
}

type ClaveTransaction @entity(immutable: true) {
  "transaction hash"
  id: Bytes!
  "tx.from"
  sender: ClaveAccount!
  "tx.to"
  to: Bytes!
  "tx.value"
  value: BigInt!
  "tx.gasPrice * tx.gasUsed"
  gasCost: BigInt!
  "type of paymaster used"
  paymaster: Paymaster!
  "block.timestamp"
  date: BigInt!
}

type InAppSwap @entity(immutable: true) {
  id: Bytes!
  account: ClaveAccount!
  tokenIn: Bytes!
  amountIn: BigInt!
  tokenOut: Bytes!
  amountOut: BigInt!
  date: BigInt!
}
